{"version":3,"sources":["PTool.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/* 参数是否为undefined */\r\n/* 参数是否为object */\r\nconst isObject = (target) => {\r\n    return Object.prototype.toString.call(target).search(/Object/) > -1;\r\n};\r\n/* 参数是否为object */\r\nconst isString = (target) => {\r\n    return Object.prototype.toString.call(target).search(/String/) > -1;\r\n};\r\n/* 参数是否为array */\r\nconst isArray = (target) => {\r\n    return Object.prototype.toString.call(target).search(/Array/) > -1;\r\n};\r\nconst isFunction = (target) => {\r\n    return Object.prototype.toString.call(target).search(/Function/) > -1;\r\n};\r\nconst toType = (target) => {\r\n    return Object.prototype.toString.call(target).split(\" \")[1].replace(\"]\", \"\");\r\n};\r\n// 是否为假值（包括对象为空，数组为空）\r\nconst isFalse = (target) => {\r\n    if (isArray(target)) {\r\n        if (JSON.stringify(target) == \"[]\")\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n    if (isObject(target)) {\r\n        if (JSON.stringify(target) == \"{}\")\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n    return !Boolean(target);\r\n};\r\n// 断言 不满足 提示错误\r\nconst assert = (condition, msg) => {\r\n    if (!condition) {\r\n        throw new Error(`[PT]:${msg}`);\r\n    }\r\n};\r\n// 是否是 Promise\r\nfunction isPromise(val) {\r\n    return val && typeof val.then === \"function\";\r\n}\n\nfunction hasOwn(obj, prop) {\r\n    return obj && obj.hasOwnProperty && obj.hasOwnProperty(prop);\r\n}\r\nfunction wrapFun(pre, wrapper) {\r\n    return function () {\r\n        try {\r\n            wrapper && wrapper.apply(this, arguments);\r\n        }\r\n        finally {\r\n            pre && pre.apply(this, arguments);\r\n        }\r\n    };\r\n}\r\nfunction extend(obj, ...args) {\r\n    if (toType(obj) != \"Object\" && toType(obj) != \"Function\")\r\n        return obj;\r\n    var source, prop;\r\n    for (var i = 0; i < args.length; i++) {\r\n        source = args[i];\r\n        for (prop in source) {\r\n            if (hasOwn(source, prop)) {\r\n                obj[prop] = source[prop];\r\n            }\r\n        }\r\n    }\r\n    return obj;\r\n}\r\nfunction objEach(obj, fn) {\r\n    if (!obj)\r\n        return;\r\n    for (var key in obj) {\r\n        if (hasOwn(obj, key)) {\r\n            if (fn(key, obj[key]) === false)\r\n                break;\r\n        }\r\n    }\r\n}\r\n/**\r\n *\r\n * @param queue 执行队列\r\n * @param fn 迭代器（）\r\n * @param cb 执行结束回调\r\n */\r\nfunction runQueue(queue, fn, cb) {\r\n    const step = (index) => {\r\n        if (index >= queue.length) {\r\n            cb();\r\n        }\r\n        else {\r\n            if (queue[index]) {\r\n                fn(queue[index], () => {\r\n                    step(index + 1);\r\n                });\r\n            }\r\n            else {\r\n                step(index + 1);\r\n            }\r\n        }\r\n    };\r\n    step(0);\r\n}\n\nvar fns = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extend: extend,\n  hasOwn: hasOwn,\n  objEach: objEach,\n  runQueue: runQueue,\n  wrapFun: wrapFun\n});\n\nvar PageState;\r\n(function (PageState) {\r\n    PageState[PageState[\"pendding\"] = 0] = \"pendding\";\r\n    PageState[PageState[\"loading\"] = 1] = \"loading\";\r\n    PageState[PageState[\"ready\"] = 2] = \"ready\";\r\n    PageState[PageState[\"unload\"] = 3] = \"unload\";\r\n})(PageState || (PageState = {}));\r\nvar ComponentState;\r\n(function (ComponentState) {\r\n    ComponentState[ComponentState[\"pendding\"] = 0] = \"pendding\";\r\n    ComponentState[ComponentState[\"attached\"] = 1] = \"attached\";\r\n    ComponentState[ComponentState[\"ready\"] = 2] = \"ready\";\r\n    ComponentState[ComponentState[\"detached\"] = 3] = \"detached\";\r\n})(ComponentState || (ComponentState = {}));\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    NavigationFailureType[NavigationFailureType[\"redirected\"] = 2] = \"redirected\";\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\n\nclass Emit {\r\n    constructor(all) {\r\n        this._all = all || new Map();\r\n    }\r\n    on(type, handler) {\r\n        var _a;\r\n        const handlers = (_a = this._all) === null || _a === void 0 ? void 0 : _a.get(type);\r\n        const added = handlers && handlers.push(handler);\r\n        if (!!added == false) {\r\n            this._all.set(type, [handler]);\r\n        }\r\n    }\r\n    off(type, handler) {\r\n        var _a, _b;\r\n        const handlers = (_a = this._all) === null || _a === void 0 ? void 0 : _a.get(type);\r\n        if (!!handler == false) {\r\n            (_b = this._all) === null || _b === void 0 ? void 0 : _b.set(type, null);\r\n        }\r\n        else if (!!handlers) {\r\n            const deleteIndex = handlers.findIndex((fn) => {\r\n                return fn === handler;\r\n            });\r\n            deleteIndex > -1 && handlers.splice(deleteIndex, 1);\r\n        }\r\n    }\r\n    emit(type, ...args) {\r\n        var _a, _b;\r\n        const wildHandler = (_a = this._all) === null || _a === void 0 ? void 0 : _a.get(\"*\");\r\n        const handlers = (_b = this._all) === null || _b === void 0 ? void 0 : _b.get(type);\r\n        wildHandler &&\r\n            wildHandler.forEach((fn) => {\r\n                fn.call(null, type, ...args);\r\n            });\r\n        handlers &&\r\n            handlers.forEach((fn) => {\r\n                fn.apply(null, args);\r\n            });\r\n    }\r\n    clean() {\r\n        this._all.clear();\r\n    }\r\n    assign(target) {\r\n        const msg = this;\r\n        let methods = [\"on\", \"off\", \"emit\"];\r\n        methods.forEach((methodName) => {\r\n            const method = msg[methodName];\r\n            target[methodName] = function () {\r\n                method.apply(msg, arguments);\r\n            };\r\n        });\r\n        return target;\r\n    }\r\n}\n\n// 遍历对象的key，数组再次遍历\r\nfunction forEachValue(obj, fn) {\r\n    Object.keys(obj).forEach((key) => fn(obj[key], key));\r\n}\r\nfunction toPromise(fn) {\r\n    if (isPromise(fn)) {\r\n        return fn;\r\n    }\r\n    else {\r\n        return function () {\r\n            let args = arguments;\r\n            return new Promise((resolve) => {\r\n                resolve(fn.apply(null, args));\r\n            });\r\n        };\r\n    }\r\n}\r\nfunction registerHook(list, fn) {\r\n    list.push(fn);\r\n    return () => {\r\n        const i = list.indexOf(fn);\r\n        if (i > -1)\r\n            list.splice(i, 1);\r\n    };\r\n}\r\nfunction parseUrlParams(url) {\r\n    var _a;\r\n    const params = {};\r\n    if (!isString(url) || url === \"\")\r\n        return params;\r\n    (_a = url\r\n        .split(\"?\")[1]) === null || _a === void 0 ? void 0 : _a.split(\"&\").map((paramsStr) => {\r\n        let [key, value] = paramsStr.split(\"=\");\r\n        params[key] = value;\r\n    });\r\n    return params;\r\n}\r\nfunction encryptionParams(params) {\r\n    return encodeURIComponent(JSON.stringify(params));\r\n}\r\nfunction decryptParams(paramsUrl) {\r\n    try {\r\n        return JSON.parse(decodeURIComponent(paramsUrl));\r\n    }\r\n    catch (_a) {\r\n        return {};\r\n    }\r\n}\n\nlet activeEffect = null;\r\nlet effectStack = [];\r\nconst originArrAddMethod = [\"push\", \"pop\", \"splice\", \"shift\", \"unshift\"];\r\nlet proxyWeakMap = new WeakMap();\r\nfunction effect(fn) {\r\n    activeEffect = fn;\r\n    effectStack.push(fn);\r\n    fn && fn();\r\n    activeEffect = effectStack.pop();\r\n}\r\nfunction reactive(obj, isShallow) {\r\n    return new Proxy(obj, {\r\n        get(target, key, recevier) {\r\n            if (key == \"model\") {\r\n                return target;\r\n            }\r\n            if (originArrAddMethod.indexOf(key) == -1) {\r\n                trace(target, key);\r\n            }\r\n            let res = Reflect.get(target, key, recevier);\r\n            if (isShallow) {\r\n                return res;\r\n            }\r\n            if (isObject(res))\r\n                return reactive(res);\r\n            if (isArray(res))\r\n                return reactive(res);\r\n            return res;\r\n        },\r\n        set(target, key, newV, recevier) {\r\n            let setResult = Reflect.set(target, key, newV, recevier);\r\n            trigger(target, key);\r\n            return setResult;\r\n        },\r\n    });\r\n}\r\nfunction trace(target, key) {\r\n    if (!activeEffect)\r\n        return;\r\n    let depsMap = proxyWeakMap.get(target);\r\n    if (!depsMap) {\r\n        proxyWeakMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let deps = depsMap.get(key);\r\n    if (!deps) {\r\n        depsMap.set(key, (deps = new Set()));\r\n    }\r\n    deps.add(activeEffect);\r\n}\r\n// 进行特化处理，当effect方法返回结果为false时，移除当前set中的对应成员\r\nfunction trigger(target, key) {\r\n    let depsMap = proxyWeakMap.get(target);\r\n    if (!depsMap)\r\n        return;\r\n    let events = depsMap.get(key);\r\n    if (!events)\r\n        return;\r\n    let runEvents = new Set(events);\r\n    runEvents.forEach((fn) => {\r\n        let runResult = fn();\r\n        if (runResult == false) {\r\n            events.delete(fn);\r\n        }\r\n    });\r\n}\n\n// store 的模块 基础数据结构，包括一些属性和方法\r\nclass Module {\r\n    constructor(rawModule, runtime) {\r\n        // 接收参数 runtime\r\n        this.runtime = runtime;\r\n        // 存储子模块\r\n        this._children = Object.create(null);\r\n        // 存储原始未加工的模块\r\n        this._rawModule = rawModule;\r\n        // 模块 state\r\n        const rawState = rawModule.state;\r\n        this.state = rawState || {};\r\n    }\r\n    // 获取是否区分命名空间 namespaced，也就是用户自定义的namespaced\r\n    get namespaced() {\r\n        return !!this._rawModule.namespaced;\r\n    }\r\n    // 添加子模块\r\n    addChild(key, module) {\r\n        this._children[key] = module;\r\n    }\r\n    // 删除子模块\r\n    removeChild(key) {\r\n        delete this._children[key];\r\n    }\r\n    // 获取子模块\r\n    getChild(key) {\r\n        return this._children[key];\r\n    }\r\n    // 更新模块，用于 热加载 hotUpdate\r\n    // 把 原始模块作为参数，分别赋值namespaced、actions、mutations、getters\r\n    update(rawModule) {\r\n        this._rawModule.namespaced = rawModule.namespaced;\r\n        if (rawModule.actions) {\r\n            this._rawModule.actions = rawModule.actions;\r\n        }\r\n        if (rawModule.getters) {\r\n            this._rawModule.getters = rawModule.getters;\r\n        }\r\n    }\r\n    // 遍历 子模块\r\n    forEachChild(fn) {\r\n        forEachValue(this._children, fn);\r\n    }\r\n    // 遍历 用户自定义的 action\r\n    forEachGetter(fn) {\r\n        if (this._rawModule.getters) {\r\n            forEachValue(this._rawModule.getters, fn);\r\n        }\r\n    }\r\n    // 遍历 用户自定义的 action\r\n    forEachAction(fn) {\r\n        if (this._rawModule.actions) {\r\n            forEachValue(this._rawModule.actions, fn);\r\n        }\r\n    }\r\n}\n\n// 模块收集器 构造模块的树结构 放到 store实例的_modules这个变量中\r\nclass ModuleCollection {\r\n    constructor(rawRootModule) {\r\n        // 未加工过的模块（用户自定义的），根模块\r\n        this.register([], rawRootModule, false);\r\n    }\r\n    get(path) {\r\n        return path.reduce((module, key) => {\r\n            return module.getChild(key);\r\n        }, this.root);\r\n    }\r\n    // 获取命名空间，最后返回类似 'cart/'\r\n    getNamespace(path) {\r\n        let module = this.root;\r\n        return path.reduce((namespaced, key) => {\r\n            module = module.getChild(key);\r\n            return namespaced + (module.namespaced ? key + \"/\" : \"\");\r\n        }, \"\");\r\n    }\r\n    // 更新模块，用于 热加载 hotUpdate\r\n    // this._modules.update();\r\n    update(rawRootModule) {\r\n        update([], this.root, rawRootModule);\r\n    }\r\n    /**\r\n     * 注册模块\r\n     * @param {Array} path 路径\r\n     * @param {Object} rawModule 原始未加工的模块\r\n     * @param {Boolean} runtime runtime 默认是 true\r\n     */\r\n    register(path, rawModule, runtime = true) {\r\n        // 断言判断用户自定义的模块是否符合要求\r\n        assertRawModule(path, rawModule);\r\n        const newModule = new Module(rawModule, runtime);\r\n        if (path.length === 0) {\r\n            this.root = newModule;\r\n        }\r\n        else {\r\n            const parent = this.get(path.slice(0, -1));\r\n            parent.addChild(path[path.length - 1], newModule);\r\n        }\r\n        // 递归注册子模块\r\n        if (rawModule.modules) {\r\n            forEachValue(rawModule.modules, (rawChildModule, key) => {\r\n                this.register(path.concat(key), rawChildModule, runtime);\r\n            });\r\n        }\r\n    }\r\n    // 注销模块\r\n    unregister(path) {\r\n        const parent = this.get(path.slice(0, -1));\r\n        const key = path[path.length - 1];\r\n        if (!parent.getChild(key).runtime)\r\n            return;\r\n        parent.removeChild(key);\r\n    }\r\n}\r\n// 更新\r\nfunction update(path, targetModule, newModule) {\r\n    targetModule.update(newModule);\r\n    if (newModule.modules) {\r\n        for (const key in newModule.modules) {\r\n            if (!targetModule.getChild(key)) {\r\n                console.warn(\"热更新时尝试添加了新的模块，若想添加新模块请重新运行编译\");\r\n                return;\r\n            }\r\n            update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);\r\n        }\r\n    }\r\n}\r\n// 对象类型\r\nconst objectAssert = {\r\n    assert: (value) => typeof value === \"function\" || (typeof value === \"object\" && typeof value.handler === \"function\"),\r\n    expected: \"希望接收类型为函数或者带有属性为<handler>的对象\",\r\n};\r\n// 用户定义的模块类型\r\nconst assertTypes = {\r\n    actions: objectAssert,\r\n};\r\n// 断言未加工的模块，也就是校验用户定义的这些模块是否符合要求。\r\nfunction assertRawModule(path, rawModule) {\r\n    Object.keys(assertTypes).forEach((key) => {\r\n        if (!rawModule[key])\r\n            return;\r\n        const assertOptions = assertTypes[key];\r\n        forEachValue(rawModule[key], (value, type) => {\r\n            assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));\r\n        });\r\n    });\r\n}\r\n// 生成断言提示消息\r\nfunction makeAssertionMessage(path, key, type, value, expected) {\r\n    let buf = `${key} should be ${expected} but \"${key}.${type}\"`;\r\n    if (path.length > 0) {\r\n        buf += ` in module \"${path.join(\".\")}\"`;\r\n    }\r\n    buf += ` is ${JSON.stringify(value)}.`;\r\n    return buf;\r\n}\n\nclass Store {\r\n    constructor(options) {\r\n        this._actions = {};\r\n        // 模块收集器，构造模块树形结构\r\n        this._modules = new ModuleCollection(options);\r\n        // 用于存储模块命名空间的关系\r\n        this._modulesNamespaceMap = Object.create(null);\r\n        // 收集getters\r\n        this._wrappedGetters = Object.create({});\r\n        const store = this;\r\n        const { dispatch } = this;\r\n        this.dispatch = function boundDispatch(type, payload) {\r\n            return dispatch.call(store, type, payload);\r\n        };\r\n        const rootState = this._modules.root.state;\r\n        installModule(this, rootState, [], this._modules.root);\r\n        // 初始化代理state\r\n        const stateProxy = reactive(rootState);\r\n        Object.defineProperty(this, \"stateProxy\", {\r\n            get() {\r\n                return stateProxy;\r\n            },\r\n        });\r\n    }\r\n    get state() {\r\n        return this.stateProxy;\r\n    }\r\n    set state(v) {\r\n        assert(false, \"禁止手动设置state\");\r\n    }\r\n    get getters() {\r\n        const store = this;\r\n        let gettersProxy = new Proxy(this._wrappedGetters, {\r\n            get(target, key, receiver) {\r\n                assert(isFunction(target[key]), `${key}未被对应模块声明`);\r\n                return Reflect.get(target, key, receiver).bind(receiver, store);\r\n            },\r\n        });\r\n        return gettersProxy;\r\n    }\r\n    // 设置 state 非生产环境报错\r\n    set getters(v) {\r\n        assert(false, \"禁止手动设置getter\");\r\n    }\r\n    dispatch(_type, _payload) {\r\n        // 获取到type和payload参数\r\n        const { type, payload } = unifyObjectStyle(_type, _payload);\r\n        const entry = this._actions[type];\r\n        // 如果不存在\r\n        if (!entry) {\r\n            // 非生产环境报错，匹配不到 action 类型\r\n            console.error(`【状态管理】查找不到对应action: ${type}`);\r\n            // 不往下执行\r\n            return;\r\n        }\r\n        const result = entry(payload);\r\n        return result.then((res) => {\r\n            return res;\r\n        });\r\n    }\r\n    registerGetters(mapGetter, pageOrComponent, contextData) {\r\n        forEachValue(mapGetter, (type, key) => {\r\n            assert(!contextData.hasOwnProperty(key), `<${pageOrComponent.is}>: getter => ${key}与页面/组件中定义的data冲突`);\r\n            let path = type.split(\"/\").slice(0, -1);\r\n            let value = type.split(\"/\").slice(-1);\r\n            // 断言：当对象中含有Getter声明的属性值时\r\n            assert(!pageOrComponent.hasOwnProperty(type), `<${pageOrComponent.is}>: getter中声明变量与本身属性冲突`);\r\n            // 实现 this.xxx 引用getter\r\n            Object.defineProperty(pageOrComponent, key, {\r\n                get() {\r\n                    return pageOrComponent.data[key];\r\n                },\r\n                set() {\r\n                    console.error(\"getter属性不允许直接赋值\");\r\n                },\r\n            });\r\n            effect(() => {\r\n                // 获取值触发订阅,经考虑setData的值为纯净对象\r\n                assert(this._wrappedGetters.hasOwnProperty(type), `<${pageOrComponent.is}>: 模块${path}中未声明相关getter：${value}`);\r\n                if ((pageOrComponent.$isPageAlive && pageOrComponent.$isPageAlive()) ||\r\n                    (pageOrComponent.$isComponentAlive && pageOrComponent.$isComponentAlive())) {\r\n                    pageOrComponent.setData({\r\n                        [key]: JSON.parse(JSON.stringify(this._wrappedGetters[type](this))),\r\n                    });\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nfunction installModule(store, rootState, path, module, hot) {\r\n    const isRoot = !path.length;\r\n    const namespaced = store._modules.getNamespace(path);\r\n    if (module.namespaced) {\r\n        // 模块命名空间map对象中已经有了，开发环境报错提示重复\r\n        if (store._modulesNamespaceMap[namespaced]) {\r\n            console.error(`重复命名模块 ${namespaced} ： ${path.join(\"/\")}`);\r\n        }\r\n        store._modulesNamespaceMap[namespaced] = module;\r\n    }\r\n    // set state\r\n    // 不是根模块且不是热重载\r\n    if (!isRoot && !hot) {\r\n        assert(module.namespaced, `模块${path}缺少命名空间属性:namespaced`);\r\n        // 获取父级的state\r\n        const parentState = getNestedState(rootState, path.slice(0, -1));\r\n        // 模块名称\r\n        // 比如 cart\r\n        const moduleName = path[path.length - 1];\r\n        // state 注册\r\n        parentState[moduleName] = module.state;\r\n    }\r\n    const local = (module.context = makeLocalContext(store, namespaced, path));\r\n    // 循环遍历注册 action\r\n    module.forEachAction((action, key) => {\r\n        const type = action.root ? key : namespaced + key;\r\n        const handler = action.handler || action;\r\n        registerAction(store, type, handler, local);\r\n    });\r\n    module.forEachGetter((getter, key) => {\r\n        const namespacedType = namespaced + key;\r\n        registerGetter(store, namespacedType, getter, local);\r\n    });\r\n    module.forEachChild((child, key) => {\r\n        installModule(store, rootState, path.concat(key), child, hot);\r\n    });\r\n}\r\nfunction registerAction(store, type, handler, local) {\r\n    assert(Boolean(store._actions[type]) == false, `模块定义方法冲突:${type}`);\r\n    // payload 是actions函数的第二个参数\r\n    store._actions[type] = function wrappedActionHandler(payload) {\r\n        let res = handler.call(store, {\r\n            dispatch: local.dispatch,\r\n            state: local.state,\r\n            rootState: store.state,\r\n            rootGetters: store.getters,\r\n        }, payload);\r\n        if (!isPromise(res)) {\r\n            res = Promise.resolve(res);\r\n        }\r\n        // 然后函数执行结果\r\n        return res;\r\n    };\r\n}\r\nfunction registerGetter(store, type, rawGetter, local) {\r\n    assert(!store._wrappedGetters[type], `getter ${type} 已经存在`);\r\n    store._wrappedGetters[type] = function wrappedGetter(store) {\r\n        return rawGetter(local.state, local.getters, store.state, store.getters);\r\n    };\r\n}\r\n// 根据路径来获取嵌套的state\r\nfunction getNestedState(state, path) {\r\n    return path.length ? path.reduce((state, key) => state[key], state) : state;\r\n}\r\nfunction makeLocalContext(store, namespaced, path) {\r\n    // 声明变量 没有命名空间\r\n    const noNamespace = namespaced === \"\";\r\n    const local = {\r\n        // 如果没有命名空间就用 store.dispatch 函数\r\n        // 否则添加模块\r\n        dispatch: noNamespace\r\n            ? store.dispatch\r\n            : (_type, _payload, _options) => {\r\n                const args = unifyObjectStyle(_type, _payload, _options);\r\n                let { type, payload, options } = args;\r\n                if (!options || !options.root) {\r\n                    // 类型 命名空间字符串拼接\r\n                    type = namespaced + type;\r\n                }\r\n                // 返回 store.dispatch\r\n                return store.dispatch(type, payload);\r\n            },\r\n    };\r\n    // 因为它们将被vm update 修改\r\n    Object.defineProperties(local, {\r\n        state: {\r\n            get: () => getNestedState(store.state, path),\r\n        },\r\n    });\r\n    return local;\r\n}\r\n// 统一成对象风格\r\nfunction unifyObjectStyle(type, payload, \r\n/**\r\n * root: 是否是根状态\r\n */\r\noptions) {\r\n    if (isObject(type) && type.type) {\r\n        options = payload;\r\n        payload = type;\r\n        type = type.type;\r\n    }\r\n    // type不是字符串类型，非生产环境报错\r\n    assert(typeof type === \"string\", `希望接受type类型为string类型，但却接收到 ${typeof type}.`);\r\n    return { type: type, payload: payload, options };\r\n}\r\nfunction usePageStore(option, store) {\r\n    option.$store = store;\r\n    option.onLoad = wrapFun(option.onLoad, function () {\r\n        // 挂载全局store\r\n        if (store) {\r\n            if (option.mapGetters) {\r\n                store.registerGetters(option.mapGetters, this, option.data || {});\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction useComponentStore(option, store) {\r\n    option.lifetimes.attached = wrapFun(option.lifetimes.attached, function () {\r\n        // 挂载全局store\r\n        if (store) {\r\n            this.$store = store;\r\n            if (option.mapGetters) {\r\n                store.registerGetters(option.mapGetters, this, option.data || {});\r\n            }\r\n        }\r\n    });\r\n}\n\nconst emit = new Emit();\r\nconst _dispatcher = new Emit();\r\nconst state = {\r\n    // 组件ID:__wxExparserNodeId__\r\n    refs: {},\r\n    // APP 隐藏时间\r\n    hideTime: 0,\r\n    // 一次性缓存（即存即用）\r\n    channel: new Map(),\r\n    store: null,\r\n    eventBus: emit,\r\n};\r\nconst stateProxy = new Proxy(state, {\r\n    get(target, p, receiver) {\r\n        return Reflect.get(target, p, receiver);\r\n    },\r\n    set() {\r\n        assert(false, \"禁止直接修改工具全局状态，如需修改请使用抛出的方法修改\");\r\n        return true;\r\n    },\r\n});\r\nconst dispatcher = _dispatcher.assign({\r\n    getRef(id) {\r\n        return state.refs[id];\r\n    },\r\n    deleteRef(id) {\r\n        delete state.refs[id];\r\n    },\r\n    setRef(id, ref) {\r\n        state.refs[id] = ref;\r\n    },\r\n    updateHideTime(time) {\r\n        state.hideTime = time;\r\n    },\r\n    put(key, value) {\r\n        state.channel[key] = value;\r\n    },\r\n    take(key) {\r\n        var v = state.channel[key];\r\n        // 释放引用\r\n        state.channel[key] = null;\r\n        return v;\r\n    },\r\n    createStore(store) {\r\n        state.store = new Store(store);\r\n    },\r\n});\n\nconst _config = {\r\n    routeFrozenTime: 2000,\r\n    nameResolve: null,\r\n    routeResolve: null,\r\n    customRouteResolve: null,\r\n};\r\nconst config = {\r\n    set: function (k, v) {\r\n        switch (k) {\r\n            case \"resolvePath\":\r\n                if (toType(v) == \"Function\") {\r\n                    _config.customRouteResolve = v;\r\n                }\r\n                break;\r\n            case \"route\":\r\n                let t = toType(v);\r\n                if (t == \"String\" || t == \"Array\") {\r\n                    let routes = t == \"String\" ? [v] : v;\r\n                    let mainRoute = routes[0];\r\n                    routes = routes.map(function (item) {\r\n                        return new RegExp(\"^\" +\r\n                            item\r\n                                .replace(/^\\/?/, \"/?\")\r\n                                .replace(/[\\.]/g, \"\\\\.\")\r\n                                .replace(/\\$page/g, \"([\\\\w\\\\-]+)\"));\r\n                    });\r\n                    _config.routeResolve = function (name) {\r\n                        return mainRoute.replace(/\\$page/g, name);\r\n                    };\r\n                    _config.nameResolve = function (url) {\r\n                        var n = \"\";\r\n                        routes.some(function (reg) {\r\n                            var m = reg.exec(url);\r\n                            if (m) {\r\n                                n = m[1];\r\n                                return true;\r\n                            }\r\n                        });\r\n                        return n;\r\n                    };\r\n                }\r\n                else {\r\n                    console.error(\"Illegal routes option:\", v);\r\n                }\r\n                break;\r\n            default:\r\n                _config[k] = v;\r\n        }\r\n    },\r\n    get: function (k) {\r\n        return _config[k];\r\n    },\r\n    setConfig: function (key, value) {\r\n        if (isObject(key)) {\r\n            objEach(key, (k, v) => {\r\n                this.set(k, v);\r\n            });\r\n        }\r\n        else {\r\n            this.set(key, value);\r\n        }\r\n        return this;\r\n    },\r\n};\n\nfunction createNavigationRedirectError(to, from) {\r\n    return createRouterError(from, to, NavigationFailureType.redirected, `[PTool]:当${from.url}跳转到${to.url}时由守卫执行了重定向`);\r\n}\r\nfunction createNavigationAbortedError(to, from) {\r\n    return createRouterError(from, to, NavigationFailureType.aborted, `[PTool]:当${from.url}跳转到${to.url}时由守卫中断了跳转`);\r\n}\r\nfunction createNavigationCancelledError(from, to) {\r\n    return createRouterError(from, to, NavigationFailureType.cancelled, `[PTool]:跳转取消 = (${from.url} => ${to.url}),执行新的跳转`);\r\n}\r\nfunction createNavigationDuplicatedError(from, to) {\r\n    const error = createRouterError(from, to, NavigationFailureType.duplicated, `[PTool]:避免重复跳转同一个页面，当前重复跳转页面路径 => \"${from.url}\".`);\r\n    // backwards compatible with the first introduction of Errors\r\n    error.name = \"NavigationDuplicated\";\r\n    return error;\r\n}\r\nfunction createRouterError(from, to, type, message) {\r\n    const error = { message };\r\n    error._isRouter = true;\r\n    error.from = from;\r\n    error.to = to;\r\n    error.type = type;\r\n    return error;\r\n}\n\nclass Router extends Emit {\r\n    constructor() {\r\n        super();\r\n        this.errorCbs = [];\r\n        this.beforeRoute = [];\r\n        this.afterRoute = [];\r\n    }\r\n    navigateTo(cfg) {\r\n        return this.route(\"navigateTo\", cfg, [].slice.call(arguments));\r\n    }\r\n    redirectTo(cfg) {\r\n        return this.route(\"redirectTo\", cfg, [].slice.call(arguments));\r\n    }\r\n    switchTab(cfg) {\r\n        return this.route(\"switchTab\", cfg, [].slice.call(arguments));\r\n    }\r\n    reLaunch(cfg) {\r\n        return this.route(\"reLaunch\", cfg, [].slice.call(arguments));\r\n    }\r\n    navigateBack(cfg) {\r\n        this.emit(\"navigateBack\", \"\", cfg.params);\r\n        return wx[\"navigateBack\"].apply(wx, [].slice.call(arguments));\r\n    }\r\n    route(type, cfg, args) {\r\n        if (cfg.name) {\r\n            cfg.url = bridge.getPageUrlByName(cfg.name);\r\n        }\r\n        const currentPageUrl = bridge.getPage().route;\r\n        const route = { url: cfg.url, name: bridge.getPageName(cfg.url) };\r\n        const current = { url: currentPageUrl, name: bridge.getPageName(currentPageUrl) };\r\n        const abort = (err) => {\r\n            if (this.errorCbs.length) {\r\n                this.errorCbs.forEach((errFn) => {\r\n                    errFn(err);\r\n                });\r\n            }\r\n            else {\r\n                console.warn(err);\r\n            }\r\n            cfg.fail && cfg.fail(err);\r\n        };\r\n        if (cfg.url == \"/\" + currentPageUrl) {\r\n            return abort(createNavigationDuplicatedError(current, route));\r\n        }\r\n        this.pendding = cfg;\r\n        const iterator = (hook, next) => {\r\n            if (this.pendding !== cfg) {\r\n                return abort(createNavigationCancelledError(current, route));\r\n            }\r\n            hook(route, current, (to) => {\r\n                // 终止跳转且后续守卫不执行\r\n                if (to === false) {\r\n                    abort(createNavigationAbortedError(current, route));\r\n                    // do nothing\r\n                }\r\n                else if (isObject(to) && (isString(to.url) || isString(to.name))) {\r\n                    // 中断原有跳转改为跳转到其他地方\r\n                    to = to;\r\n                    if (isObject(to) && to.replace) {\r\n                        this.redirectTo(to);\r\n                    }\r\n                    else {\r\n                        try {\r\n                            this.navigateTo(to);\r\n                        }\r\n                        catch (_a) {\r\n                            this.switchTab(to);\r\n                        }\r\n                    }\r\n                    abort(createNavigationRedirectError(current, route));\r\n                }\r\n                else {\r\n                    next(to);\r\n                }\r\n            });\r\n        };\r\n        runQueue(this.beforeRoute, iterator, () => {\r\n            this.emit(type, cfg.url, cfg.params);\r\n            this.pendding = null;\r\n            // 会存在不兼容接口，例如：reLaunch\r\n            if (wx[type]) {\r\n                return wx[type].apply(wx, args);\r\n            }\r\n        });\r\n    }\r\n    redirectDelegate(target) {\r\n        [\"navigateTo\", \"redirectTo\", \"switchTab\", \"reLaunch\", \"navigateBack\"].map((methodName) => {\r\n            target[methodName] = this[methodName];\r\n        });\r\n    }\r\n    beforeEach(fn) {\r\n        return registerHook(this.beforeRoute, fn);\r\n    }\r\n    afterEach(fn) {\r\n        return registerHook(this.afterRoute, fn);\r\n    }\r\n    onError(fn) {\r\n        this.errorCbs.push(fn);\r\n    }\r\n}\r\nconst router = new Router();\n\nconst navigate = route({ type: \"navigateTo\" });\r\nconst redirect = route({ type: \"redirectTo\" });\r\nconst switchTab = route({ type: \"switchTab\" });\r\nconst reLaunch = route({ type: \"reLaunch\" });\r\nconst navigateBack = (option) => {\r\n    router.navigateBack(option);\r\n};\r\nvar bridge = {\r\n    redirectDelegate: function (emitter, dispatcher) {\r\n        [\"navigateTo\", \"redirectTo\", \"switchTab\", \"reLaunch\", \"navigateBack\"].forEach(function (k) {\r\n            emitter.on(k, function (url, params) {\r\n                let name;\r\n                if (k === \"navigateBack\") {\r\n                    let backPage = getCurrentPages()[getCurrentPages().length - 2];\r\n                    if (backPage) {\r\n                        name = getPageName(\"/\" + backPage.route);\r\n                    }\r\n                }\r\n                else {\r\n                    name = getPageName(url);\r\n                }\r\n                name && dispatcher.emit(k + \":\" + name, url, params);\r\n            });\r\n        });\r\n    },\r\n    mountRef: function (e) {\r\n        let componentID = e.detail;\r\n        let ref = dispatcher.getRef(componentID);\r\n        if (!ref)\r\n            return;\r\n        let refName = ref._$ref;\r\n        if (refName && this.$refs) {\r\n            this.$refs[refName] = ref;\r\n        }\r\n        ref._$attached(this);\r\n    },\r\n    methods: function (ctx) {\r\n        // 组件快速调用\r\n        ctx.$refs = {};\r\n        // 一次性存取\r\n        ctx.$put = dispatcher.put;\r\n        ctx.$take = dispatcher.take;\r\n        /**\r\n         * 路由方法\r\n         */\r\n        ctx.$route = ctx.$navigate = navigate;\r\n        ctx.$redirect = redirect;\r\n        ctx.$switch = switchTab;\r\n        ctx.$reLaunch = reLaunch;\r\n        ctx.$back = navigateBack;\r\n        /**\r\n         * 页面预加载\r\n         */\r\n        ctx.$preload = preload;\r\n        /**\r\n         * 页面信息\r\n         */\r\n        ctx.$curPage = getPage;\r\n        ctx.$curPageName = curPageName;\r\n    },\r\n    getPageUrlByName,\r\n    getPageName,\r\n    getPage,\r\n};\r\nfunction route({ type }) {\r\n    return function (url, option = {}) {\r\n        const pagepath = getPageUrlByName(url);\r\n        const params = parseUrlParams(url);\r\n        if (params.encodeData) {\r\n            option.params = Object.assign(decryptParams(params.encodeData), option.params);\r\n            delete params.encodeData;\r\n        }\r\n        // append querystring\r\n        const query = Object.entries(params)\r\n            .map((item) => item.join(\"=\"))\r\n            .join(\"&\");\r\n        option.url = `${pagepath}${!isFalse(option) ? \"?encodeData=\" + encryptionParams(option.params) : \"\"}${query ? \"&\" + query : \"\"}`;\r\n        router[type](option);\r\n    };\r\n}\r\nfunction preload(url, params) {\r\n    var name = getPageName(url);\r\n    name && dispatcher && dispatcher.emit(\"preload:\" + name, url, params);\r\n}\r\nfunction getPageUrlByName(url) {\r\n    var parts = url.split(/\\?/);\r\n    var pagepath = parts[0];\r\n    if (/^[\\w\\-]+$/.test(pagepath)) {\r\n        pagepath = (config.get(\"customRouteResolve\") || config.get(\"routeResolve\"))(pagepath);\r\n    }\r\n    if (!pagepath) {\r\n        // @ts-ignore\r\n        throw new Error(\"Invalid path:\", pagepath);\r\n    }\r\n    return pagepath;\r\n}\r\nfunction getPage() {\r\n    return getCurrentPages().slice(0).pop();\r\n}\r\nfunction getPageName(url) {\r\n    var m = /^[\\w\\-]+(?=\\?|$)/.exec(url);\r\n    return m ? m[0] : config.get(\"nameResolve\")(url);\r\n}\r\nfunction curPageName() {\r\n    var route = getPage().route;\r\n    if (!route)\r\n        return \"\";\r\n    return getPageName(route);\r\n}\n\nconst defaultState = { lifeState: PageState.pendding, preloadFn: null };\r\nconst namePool = {};\r\n// 总事件管理\r\nfunction IPage(name, option) {\r\n    if (isObject(name)) {\r\n        option = name;\r\n        name = option.name || \"_unknow\";\r\n    }\r\n    if (namePool[name] && name !== \"_unknow\") {\r\n        assert(true, `存在重名路由${name}，请确认该路径名称是否重复 // PS：目前没找到更好的页面名称设置的逻辑，如果有更好的思路欢迎到https://github.com/pangolierse/wx-ez-tool提`);\r\n    }\r\n    else {\r\n        namePool[name] = true;\r\n    }\r\n    option.$name = name;\r\n    option.$state = JSON.parse(JSON.stringify(defaultState));\r\n    // 页面是否存活\r\n    option.$isPageAlive = function () {\r\n        var _a;\r\n        return ((_a = this.$state) === null || _a === void 0 ? void 0 : _a.lifeState) !== PageState.unload;\r\n    };\r\n    // 若项目声明了状态管理器则对每个页面进行检测\r\n    if (stateProxy.store) {\r\n        usePageStore(option, stateProxy.store);\r\n    }\r\n    loadBeforePageInitExtend(option);\r\n    if (option.onNavigate) {\r\n        assert(name !== \"_unknow\", \"用到onNavigate方法必须要为页面添加name属性，name值需与APP中的路由规则相匹配\");\r\n        let onNavigateHandler = function (url, params) {\r\n            option.onNavigate({ url, params });\r\n        };\r\n        console.log(`Page[${name}] define \"onNavigate\"`);\r\n        dispatcher.on(`navigateTo:${name}`, onNavigateHandler);\r\n        dispatcher.on(`redirectTo:${name}`, onNavigateHandler);\r\n        dispatcher.on(`switchTabTo:${name}`, onNavigateHandler);\r\n        dispatcher.on(`reLaunchTo:${name}`, onNavigateHandler);\r\n    }\r\n    if (option.onBack) {\r\n        assert(name !== \"_unknow\", \"用到onBack方法必须要为页面添加name属性，name值需与APP中的路由规则相匹配\");\r\n        console.log(`Page[${name}] define \"onBack\"`);\r\n    }\r\n    option.onLoad = wrapFun(option.onLoad, function (onLoadOption) {\r\n        // Back方法特殊处理可能需要获取到页面实例，所以放在onLoad的时候注册\r\n        if (option.onBack) {\r\n            let onNavigateBackHandler = (url, params) => {\r\n                this.onBack(params);\r\n            };\r\n            dispatcher.on(`navigateBack:${name}`, onNavigateBackHandler);\r\n        }\r\n        if (onLoadOption === null || onLoadOption === void 0 ? void 0 : onLoadOption.encodeData) {\r\n            // 转化页面参数\r\n            onLoadOption.params = decryptParams(onLoadOption.encodeData);\r\n            delete onLoadOption.encodeData;\r\n        }\r\n        // 防止 热更新时页面报错\r\n        if (!!this.$state == false) {\r\n            this.$state = JSON.parse(JSON.stringify(defaultState));\r\n        }\r\n        this.$state.lifeState = PageState.loading;\r\n        option.onAwake &&\r\n            dispatcher.on(\"app:sleep\", (t) => {\r\n                option.onAwake.call(this, t);\r\n            });\r\n    });\r\n    /**\r\n     * preload lifecycle method\r\n     */\r\n    if (option.onPreload) {\r\n        assert(name !== \"_unknow\", \"用到onPreload方法必须要为页面添加name属性，name值需与APP中的路由规则相匹配\");\r\n        console.log(`Page[${name}] define \"onPreload\"`);\r\n        dispatcher.on(\"preload:\" + name, function (url, params) {\r\n            option.onPreload = toPromise(option.onPreload);\r\n            option.$state.preloadFn = option.onPreload({ url, params });\r\n        });\r\n        // preload将在onLoad时等待完成\r\n        option.onLoad = wrapFun(option.onLoad, function () {\r\n            this.$state = this.$state || {};\r\n            if (this.$state.preloadFn) {\r\n                this.$state.preloadFn\r\n                    .then((...args) => {\r\n                    option.onPreloaded(...args);\r\n                })\r\n                    .catch((err) => {\r\n                    console.log(\"页面在预加载时出错：\", err);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    bridge.methods(option);\r\n    option.$m = bridge.mountRef;\r\n    option.onReady = wrapFun(option.onReady, function () {\r\n        this.$state.lifeState = PageState.ready;\r\n        router.emit(\"page:ready\");\r\n    });\r\n    option.onUnload = wrapFun(option.onUnload, function () {\r\n        this.$state.lifeState = PageState.unload;\r\n        router.emit(\"page:unload\");\r\n    });\r\n    if (\"onPageLaunch\" in option) {\r\n        option.onPageLaunch();\r\n    }\r\n    loadafterPageInitExtend(option);\r\n    return Page(option);\r\n}\r\nfunction loadBeforePageInitExtend(option) {\r\n    const beforePageInitExtend = config.get(\"beforePageInitExtend\") || null;\r\n    if (beforePageInitExtend) {\r\n        assert(isFunction(beforePageInitExtend), \"beforePageInitExtend 必须为函数\");\r\n        beforePageInitExtend({\r\n            option,\r\n            fns,\r\n            state: stateProxy,\r\n            dispatcher,\r\n        });\r\n    }\r\n}\r\nfunction loadafterPageInitExtend(option) {\r\n    const afterPageInitExtend = config.get(\"afterPageInitExtend\") || null;\r\n    if (afterPageInitExtend) {\r\n        assert(isFunction(afterPageInitExtend), \"afterPageInitExtend 必须为函数\");\r\n        afterPageInitExtend({\r\n            option,\r\n            fns,\r\n            state: stateProxy,\r\n            dispatcher,\r\n        });\r\n    }\r\n}\n\n// @ts-ignore\r\nfunction IApp(option) {\r\n    var _a, _b;\r\n    assert(!!((_b = (_a = option === null || option === void 0 ? void 0 : option.config) === null || _a === void 0 ? void 0 : _a.route) === null || _b === void 0 ? void 0 : _b.length), \"config.route is necessary !!!\");\r\n    if (option.config) {\r\n        config.setConfig(option.config);\r\n    }\r\n    var ctx = option;\r\n    /**\r\n     * APP sleep logical\r\n     */\r\n    option.onLaunch = wrapFun(option.onLaunch, function () {\r\n        this.$store = stateProxy.store;\r\n    });\r\n    option.onShow = option.onShow ? wrapFun(option.onShow, appShowHandler) : appShowHandler;\r\n    option.onHide = option.onHide ? wrapFun(option.onHide, appHideHandler) : appHideHandler;\r\n    option.onLaunch = wrapFun(option.onLaunch, function () {\r\n        ctx = this;\r\n    });\r\n    if (option.onAwake) {\r\n        dispatcher.on(\"app:sleep\", function (t) {\r\n            option.onAwake.call(ctx, t);\r\n        });\r\n    }\r\n    App(option);\r\n}\r\nfunction appShowHandler() {\r\n    if (!stateProxy.hideTime)\r\n        return;\r\n    let t = stateProxy.hideTime;\r\n    dispatcher.updateHideTime(0);\r\n    dispatcher.emit(\"app:sleep\", new Date().getTime() - t);\r\n}\r\nfunction appHideHandler() {\r\n    dispatcher.updateHideTime(new Date().getTime());\r\n}\n\nfunction IComponent(option) {\r\n    option.$state = {};\r\n    option.$state.lifeState = ComponentState.pendding;\r\n    option.lifetimes = option.lifetimes || {};\r\n    // 若项目声明了状态管理器则对每个页面进行检测\r\n    if (stateProxy.store) {\r\n        useComponentStore(option, stateProxy.store);\r\n    }\r\n    option.properties = extend({}, option.properties, {\r\n        ref: {\r\n            type: String,\r\n            value: \"\",\r\n            observer: function (next) {\r\n                /**\r\n                 * 支持动态 ref\r\n                 */\r\n                if (this._$ref !== next) {\r\n                    let $refs = this.$parent && this.$parent.$refs;\r\n                    if ($refs) {\r\n                        let ref = $refs[this._$ref];\r\n                        delete $refs[this._$ref];\r\n                        this._$ref = next;\r\n                        if (ref && next) {\r\n                            $refs[next] = ref;\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n        },\r\n    });\r\n    option.lifetimes.attached = wrapFun(option.lifetimes.attached, function () {\r\n        bridge.methods && bridge.methods(this);\r\n        this.$state = option.$state;\r\n        this.$state.lifeState = ComponentState.attached;\r\n        this.$id = this.__wxExparserNodeId__;\r\n        dispatcher.setRef(this.$id, this);\r\n        this._$ref = this.properties.ref || this.properties._ref;\r\n        this.$isComponentAlive = function () {\r\n            return this.$state.lifeState !== ComponentState.detached;\r\n        };\r\n        this.triggerEvent(\"mount\", this.$id);\r\n    });\r\n    option.lifetimes.ready = wrapFun(option.lifetimes.ready, function () {\r\n        this.$state = this.$state || {};\r\n        this.$state.lifeState = ComponentState.ready;\r\n    });\r\n    option.lifetimes.detached = wrapFun(option.lifetimes.detached, function () {\r\n        dispatcher.deleteRef(this.$id);\r\n        let $refs = this.$parent && this.$parent.$refs;\r\n        let refName = this._$ref;\r\n        if (refName && $refs) {\r\n            delete $refs[refName];\r\n        }\r\n        this.$parent = null;\r\n        this.$state.lifeState = ComponentState.detached;\r\n    });\r\n    option.methods = extend({}, option.methods, {\r\n        _$attached: function (parent) {\r\n            this.$root = parent.$root || parent;\r\n            this.$parent = parent;\r\n        },\r\n        $m: bridge.mountRef,\r\n    });\r\n    return Component(option);\r\n}\n\nconst PTool = {\r\n    Page: IPage,\r\n    Component: IComponent,\r\n    App: IApp,\r\n    router: router,\r\n    createStore: dispatcher.createStore,\r\n};\r\nObject.defineProperty(PTool, \"store\", {\r\n    get() {\r\n        return stateProxy.store;\r\n    },\r\n    configurable: false,\r\n});\r\nstateProxy.eventBus.assign(PTool);\r\nbridge.redirectDelegate(router, dispatcher);\r\nrouter.redirectDelegate(PTool);\r\n// 自动注入PTool到全局\r\nObject.defineProperty(Object.prototype, \"PTool\", {\r\n    value: PTool,\r\n    configurable: false,\r\n    enumerable: false,\r\n});\n\nmodule.exports = PTool;\n"]}